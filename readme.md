# Updateable Queue

For this assignment, you will be implementing some additonal 
functionality within the linked list, and using it to build
a data structure useful for interactive, collaborative applications - 
an **updateable queue**.  

The concept behind an updateable queue is that it is used in 
a **producer consumer** modelled application - where events and updates
are being generated by certain actors (programs, potentially across
a network), and consumed by another (i.e. a renderer for a game).  

In this assignment, we won't be simulating multiple programs, networks, 
or anything resembling a full fledged application (we will do some of that 
later).  For this assignment, we are simply testing out the functionality.

## Events and Updates
An updateable queue (UPQ) support two types of "payloads" which are inserted
at end of the queue (which we will implement with our linked list) and read
from the front of the queue (and removed).  The two types are **event** and **update**. 

The concept is best illustrated by thinking about a multiplayer, networked video game - 
let's say with 2 players.  **Updates** are position (x, y, z) coordinates of the player, 
which are written to the queue (put) as the player moves.  **Events** are things that happen 
in the game, which need to be accurately recorded - they effect logic of game play.

The reason an updateable queue is useful is because often updates are streamed into 
a central game engine (rules engine, rendering engine) faster than they can be processed.  
While each position update is important, if the rendering engine isn't keeping up, 
intermediate positions of players isn't all that critical.  The rendering engine
needs to know where a player is "right now".  

### Updates
For an event, we will support a label (i.e. Player 1, Player 2) and a double array often
length 3 (x, y, z).  When an update is added to the queue, it will not simply be added
to the end.  Instead, the queue will be searched (from tail to head) for an update
with the same label.  If an update with a matching label is already in the queue (and another
yet removed), then the update is replaced (overwritten) - since the unprocessed positional
update is obsolete.  If an update with a matching label is not found, then the update is
simply added to the end of the queue.  

This logic holds, but is made a bit more complicated by the presence of **events**.

### Events
An event represents something critical that has happened in the environment.  In a game, 
this might be a collision, or some other important event that would need to be rendered
or recorded.  When an event occurs, the consumer of the positional updates will want
to know exactly where each player was prior to the event.  

When an event is added, it always gets added to the end of the queue.  The presence of
an event represents a "stop" for update logic however.   When adding updates, the search 
for matching updates to replace stops whenever an event is encounted.  


## Example;
Let's imagine that we are tracking only two types of events - application start, and collisions.  
Further, we have two "players" - Player 1 and Player 2.  Let's also assume that 
the reader of the queue is slow, in fact so slow that nothing is read until the following sequence
is completed:

1. Event:  Application start
2. Update - Player 1 Position (1.0, 1.0, 1.0)
3. Update - Player 2 Position (5, 5, 5)
4. Update - Player 1 Position (1.2, 1.2, 1.8)
5. Update - Player 1 Position (2.4, 2.2, 1.9)
6. Event:  Collision
7. Update - Player 2 Position (5.4, 5.2, 5.8)
8. Update - Player 1 Position (0.9, 1.1, 0.7)


For a typical queue, the contents once this sequence is written would simply
be 8 payloads - 2 events and 6 different position updates.  However, for an updateable queue, 
we would only have 6.  Here's why:

The first event is added to the queue, followed by position updates for player 1
and player 2.  So far we have three payloads in the queue.

When the next player 1 update is added (action #4), instead of being added it "bubbles up"
and replaces action #2 - overwriting player 1's position.  This happens again when player 1's
position is added once more.  So, prior to the collision event, we still only have 3 items
in the queue.

The collision event is then added.  The subsequent player 1 and player 2 position updates
happen AFTER the collision, so they do not bubble up to replace the previous positions.  The collision, 
plus the two position updates give us the final 3 items.  

It's important to know that at any time the queue can be read - thus removing the 
first item.  


# Assignment
You must implement the UQP implementation using the linked list implementation 
that is partially provided in list.h/list.c.  

TODO:  You will need to implement `linkedlist_pop_front` as started in list.h and list.c

TODO:  upq.h and upq.c are only partially created.  The functions are present, and documented, 
	   but most are not implemented.  

Inside `test.c` you will find three test cases, with assertions.  Running your program will
call the test cases.  **DO NOT CHANGE THE TEST CASES**, although you are free to add more.  

Your code will be evaluated as follows:
1.  Do the supplied test cases all pass?
2.  Are there memory leaks present that are not captured by the tests?
3.  Does your code pass additional (undisclosed!) tests, which further evaluate to logic?

Note - any additional tests that I run will simply exercise the required logic in more detail, 
I've explained exactly what the queue implementation should do.

# Getting started
You should install `CMake` on your machine.  I have supplied a `CMakeLists.txt` that is sufficient
for this assignment.  Building and running can be accomplished as follows, provided you 
have CMake installed on your machine, and you have a suitable C compiler.

```
cd <the directory with the code>
cmake .
make
./upq-test
```

